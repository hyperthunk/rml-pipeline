Leveraging Planning Phase for Adaptive String Pool Thresholds
You've hit on a key insight! The planning phase is perfectly positioned to help us establish intelligent thresholds and sizing based on document structure.

Planning Phase Data We Can Leverage
Looking at the Planner.fs code, we already collect several metrics that could inform string pool configuration:

Path Complexity Analysis:

F#
// From Planner.fs
let iteratorDepth = 
    triplesMap.LogicalSource.SourceIterator 
    |> Option.map (fun path -> path.Split('.').Length)
    |> Option.defaultValue 1
Predicate-Object Volume Estimates:

F#
// We already count these during planning
complexity <- complexity + pom.PredicateMap.Length * 5
complexity <- complexity + pom.ObjectMap.Length * 5
Dependency Group Structure:

F#
// We analyze how mappings relate to each other
let dependencyGroups = groupByDependencies finalPlans
Path Overlap Detection:

F#
// We detect overlapping paths during planning
let pathOverlap = 
    if plan1.IteratorPathId = plan2.IteratorPathId then 1.0
    else 0.0
Adaptive Sizing Strategy
We can implement a sizing strategy that:

Analyzes RML complexity to predict string volume
Examines path structure to estimate field name reuse
Studies dependency groups to optimize group-level thresholds
Evaluates overlaps to predict promotion patterns
Implementation Approach
I propose adding a StringPoolSizing module that integrates with the planning phase:

F#
type StringPoolSizingConfig = {
    // Eden space sizing
    GlobalEdenSize: int
    GroupEdenSizes: Map<DependencyGroupId, int>
    WorkerEdenSize: int
    
    // Chunk sizing
    InitialChunkSize: int
    SecondaryChunkSize: int
    
    // Promotion thresholds
    WorkerPromotionThreshold: int
    GroupPromotionThreshold: int
    
    // Temperature adjustment factors
    FieldPathTemperatureFactor: float
    URITemplateTemperatureFactor: float
    LiteralTemperatureFactor: float
}

let calculateOptimalSizing (rmlPlan: RMLPlan) : StringPoolSizingConfig =
    // Extract plan metrics
    let totalComplexity = 
        rmlPlan.OrderedMaps |> Array.sumBy (fun m -> m.EstimatedComplexity)
        
    let maxPathDepth =
        rmlPlan.OrderedMaps
        |> Array.map (fun m -> m.PathSegments.Length)
        |> Array.max
        
    let averagePredicatesPerMap =
        rmlPlan.OrderedMaps
        |> Array.averageBy (fun m -> float m.PredicateTuples.Length)
    
    // Calculate expected string volumes
    let expectedSchemaStrings = 
        totalComplexity * 2 + (maxPathDepth * 5)
        
    let expectedRuntimeStrings =
        // Estimate based on predicate patterns and nesting
        int (averagePredicatesPerMap * float maxPathDepth * 10.0)
    
    // Configure group-specific sizes
    let groupSizes =
        [| for i = 0 to rmlPlan.DependencyGroups.GroupStarts.Length - 1 do
            let members = rmlPlan.DependencyGroups.GetGroup(i)
            let groupComplexity = 
                members |> Array.sumBy (fun idx -> 
                    rmlPlan.OrderedMaps.[idx].EstimatedComplexity)
                    
            // Calculate ideal size for this group
            let groupSize = max 5000 (groupComplexity * 10)
            yield (DependencyGroupId i, min 50000 groupSize)
        |] |> Map.ofArray
    
    // Calculate promotion thresholds based on expected reuse
    let workerThreshold =
        // Higher threshold for deeper paths (more unique data)
        max 20 (maxPathDepth * 5)
        
    let groupThreshold =
        // Scale with complexity
        max 100 (totalComplexity * 2)
    
    {
        GlobalEdenSize = max 10000 (expectedSchemaStrings * 2)
        GroupEdenSizes = groupSizes
        WorkerEdenSize = max 1000 (expectedRuntimeStrings / 10)
        
        InitialChunkSize = 1000
        SecondaryChunkSize = 5000
        
        WorkerPromotionThreshold = workerThreshold
        GroupPromotionThreshold = groupThreshold
        
        // Temperature adjustment factors
        FieldPathTemperatureFactor = 1.5
        URITemplateTemperatureFactor = 2.0
        LiteralTemperatureFactor = 0.5
    }
Integrating with RML Plan Creation
We would integrate this with the existing plan creation:

F#
let createRMLPlan (triplesMaps: TriplesMap[]) (config: PlannerConfig) : RMLPlan =
    // Existing planning code...
    
    // Calculate optimal string pool sizing based on plan analysis
    let stringPoolConfig = calculateOptimalSizing plan
    
    // Configure string pools with these settings
    let stringPoolHierarchy = 
        StringPool.createWithConfig planningStrings stringPoolConfig
    
    // Continue with existing code...