{
    "task": "semantic data integration",
    "context": "an architeture for harmonizing heterogeneous datasets using linked data semantics",
    "business-problem": "conforming a complex hetergeneous IT estate (+ large external landscape) to a canonical model is prohibitively expensive",
    
    "requirement": "this code provides a reverse lookup from string to stringid, so we can avoid interning the same string multiple times",
    "constraints": {
        "no overwriting slots": "If you've stored \"$.contract.clauses[*].clauseId\" and for the same id you later get back \"POST\" that's going to break the program",
        "no-excessive-allocations": "We use string interning to avoid GC pressure, so an allocation-heavy solution isn't a good fit",
        "no-linear-probing": "Linear probing can lead to cache misses and will increase latency, which we want to avoid",
        "string-id-behaviour": {
            "string-id-temperature": "stringid can still maintain temp updates in-situ",
            "string-id-promotions": "stringid can still be used to look up a new id when strings are promoted",
            "string-id-idempotency": "a stringid always returns the string that was interned against that id"
        },
        "no-locking": "Locking based solutions or ConcurrentDictionary are not suitable for this scenario"
    },
    "previously-considered": {
        "concurrent-tries": {
            "previously-discounted-reason": "Good option for throughput, however lots of intermediate node creation could lead to GC pressure, which would defeat the object of string interning - which is largely to avoid GC pressure",
            "potential-option": "Could we implement a CTrie (concurrent thread-safe lock-free implementation of a hash array mapped trie) using structs? How would such an implementation avoid allocations, since intermediate nodes are usually allocated on the heap? Could this be done with ValueOption?"
        },
        "left-right-lockless-abstraction": "a concurrency primitive which allows lock-free/wait-free reads of any mutable datastructure. Conceptually left-right can be understood as a concurrency primitive that maintains two copies of a datastructure with a pointer (switch) directing traffic for reads and writes in separate directions. Could be made to work by atomically CAS on the pointer between copies?",
        "locking-based-solutions": "Contention management is easier to reason about, but under heavy load we regularly see the convoy effect leading to thread starvation - solutions using locks or ConcurrentDictionary are off the table"
    }

}